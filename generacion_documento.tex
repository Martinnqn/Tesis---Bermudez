\chapter{Generación del documento de texto}

\section{Diseño}
En este capítulo se diseñará e implementará el proceso de generación del documento de texto. Elegimos organizar toda la información de la ontología generando un documento dividido en secciones, subsecciones y párrafos. Para alcanzar el documento final, se crearon módulos teniendo como referencia las actividades de la generación de lenguaje natural nombradas en la Sección \ref{sec:tareas_gnl}. Los tres módulos principales son \emph{Macro planificación}, \emph{Micro planificación} y \emph{Realización}. Dentro de cada módulo se desarrollaron submódulos, para resolver cada problema específico. 

Para comenzar con la generación de un documento de texto, se planteó un Plan de Documento. Este Plan tiene la estructura resultante del Organizador de la Información. Sin embargo, para crear el documento en la etapa de Macro Planificación, se reemplazó el módulo Generador del Árbol de Entidades del Organizador de Información, por un nuevo módulo específico del Macro Planning. El motivo de este reemplazo es evitar la creación de interfaces entre el Organizador de Información y el Macro Planning, por el overhead que estas suponen, ya que la creación del Árbol de Entidades y la Macro Planificación resultan ser procesos equivalentes, por lo que pueden ser reemplazables, evitando recorrer el doble de veces la estructura jerárquica.

En la figura~\ref{fig:modulos_plan_documento} se puede ver el nuevo módulo Generador del Plan de Documento, que retorna como salida un Plan de Documento.

\begin{figure}[H]
    \centering
    \includegraphics{img/generacion_documento/modulos_plan_documento.pdf}
    \caption{Módulos para la generación del Plan de Documento.}
    \label{fig:modulos_plan_documento}
\end{figure}

Cabe aclarar que este es un Plan de Documento inicial que solo cuenta con una primera distribución de la información que estará contenida en el texto final. En el Documento Final, la realización de la estructura y la realización lingüística (secciones, párrafos y oraciones) se realizarán en las etapas de Micro Planificación y Realización, como se ve en la figura~\ref{fig:modulos_documento_final}.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{img/generacion_documento/modulos_documento_final.pdf}
    \caption{Módulos para la generación del documento final.}
    \label{fig:modulos_documento_final}
\end{figure}

\section{Diseño Macro Planning}
\label{sec:macro_planning}
En esta etapa se planificará la estructura del documento. Como nombramos anteriormente, la organización a priori de la información, realizada en el capítulo anterior, facilita la tarea de Macro Planificación. Por este motivo, se decidió hacer una arquitectura monolítica entre el Organizador de Información y el Macroplanificador. 

El documento de texto estará representado internamente con una estructura basada en componentes. Esta representación prepara el terreno para que, luego de la Micro Planificación, el Realizador decida el diseño final del documento.

La representación interna del documento de texto tiene en cuenta los siguientes criterios:
\begin{itemize}
    \item Cada Entidad presente en la estructura que resulta del Organizador de Información es considerada un tópico. 
    \item A cada tópico del primer nivel le corresponde una sección. Los tópicos anidados (Subclases, Individuos y Relaciones) se corresponden a subsecciones (secciones anidadas).
    \item Cada sección está compuesta de al menos un párrafo y un título.
    \item Cada párrafo trata un único tópico, el cual puede ser una clase o un individuo. También, un párrafo puede o no tener alguna sentencia. Esto se debe a que no todas las entidades tienen asociados axiomas que la describan.
\end{itemize}

\subsection{Secciones y párrafos}
Las Secciones tiene como objetivo principal delimitar la información asociada a una Entidad, segmentando el texto con el fin de mantener la coherencia global.

Dentro de una sección para una Clase, se verbalizarán sus axiomas y se enumerarán sus Individuos, Subclases y Relaciones, todo en un párrafo. Enumerar esta información resulta conveniente ya que luego se crearán subsecciones para cada uno de esos componentes.

En una sección asociada a una Relación, solo habrán subsecciones acerca de las Entidades que pertenecen a la Relación.

En una sección para Individuos, se creará un párrafo para describir sus propiedades.

\subsubsection{Subsecciones}
Las subsecciones son secciones anidadas dentro de otras secciones. Una subsección puede surgir a partir de un Individuo, Subclases o Relaciones. Cuando surge a partir de un Individuo, la subsección trata como tópico al Individuo; cuando surge a partir de una Subclase, el tópico principal es la Subclase; y cuando surge a partir de una Relación, el tópico principal resulta ser el rango de la Relación, es decir, otra Clase.

\subsection{Oraciones}
Las oraciones pertenecen a los párrafos por lo que tratan un solo tópico. Cada oración que tenga como tópico a una Clase,  aborda un solo tipo de información, por lo que existe una oración para las clases disjuntas, una oración para las clases equivalentes, y así con los demás tipos de información. Cada oración correspondientes a un Individuo contiene las propiedades con sus valores declaradas sobre el Individuo.

Al tratar un solo tipo de información por oración, se maximiza la cohesión dentro de cada oración.


\subsection{Diagrama de clases}
En la figura \ref{fig:diagrama_clases_macroplanificador} se muestra el diagrama de clases correspondiente al Macroplanificador. La clase TextManager es la implementación del módulo Generador del Plan de Documento. Esta clase se encarga de crear la clase Text, que es la representación interna de un documento de texto. El documento está compuesto por Secciones, Párrafos y Oraciones, cada uno de los cuales tiene asociado su respectiva clase Section, Paragraph y Statement. Las clases StatementComponent y Word son específicas del Micro Planning por lo que se explicarán más adelante.

\begin{figure}
    \centering
    \includegraphics{img/generacion_documento/diagrama_clases_macroplanificador.pdf}
    \caption{Diagrama de clases del Macro Planning.}
    \label{fig:diagrama_clases_macroplanificador}
\end{figure}

\section{Implementación Macro Planning}
La clase principal del Macroplanificador es \emph{TextManager}. Para crear el Documento Inicial, recorre las Entidades de la misma manera que la clase \emph{GeneratorTreeManager}, explicada en la Figura~\ref{fig:clase_generator_tree}, con la diferencia que crea el objeto \emph{Text} y los objetos \emph{Section} asociados a cada Entidad. Ya que el recorrido es equivalente no se presentará su implementación, en cambio comenzaremos a mostrar las clases que componen el Documento de Texto.

La clase \emph{Text} solo contiene los objetos del primer nivel del Documento de Texto. Tiene acceso a las secciones principales y a las secciones que contienen la información marginada. 

La clase \emph{Section} contiene la información referida a una Sección, como título, párrafos, sus subsecciones y el tópico asociado. Implementa el método de realización del Documento Final, el cual se verá en el Capítulo de Realización.

Cada \emph{Section} se encarga de crear el \emph{Paragraph} correspondiente a su tópico.

La clase \emph{Paragraph} contiene una lista de todas las \emph{Statement} referidas a su Tópico. 

Cada \emph{Paragraph} se encarga de crear las \emph{Statement} correspondientes para el Tópico que recibe, y asociarles los componentes que describen al Tópico. Adicionalmente el párrafo recibe el lenguaje del texto, por lo que debe instanciar las \emph{Statement} adecuadas, ya sea \emph{StatementEnglish} o \emph{StatementSpanish}.

La clase \emph{Statement} contiene la información que tendrá cada oración. Será usada por el Microplanificador para verbalizar la información e implementar los métodos de la etapa de Micro Planning. 

\section{Diseño Micro Planning}
En esta estapa se llevarán a cabo las tareas crear las oraciones del documento de texto.
para describir una Entidad en lenguaje natural a partir de la información que contiene cada oración creada en el Macro Planning. Esta descripción en lenguaje natural se alcanza a través de una o varias oraciones producidas con una estructura que se adapte a la gramática del lenguaje español.

Como existen diversas estructuras sintácticas para expresar un mismo contenido, a modo de simplificación se asoció a cada constructor OWL solo algunas formas de verbalización. Se trató de generar oraciones que sean fieles al significado expresado en los axiomas y de evitar ambigüedades.

Para poder trabajar con patrones de la gramática del lenguaje humano (ya sea español o inglés), se utilizó un \emph{POS Tagger} para etiquetar las palabras.

\subsection{Verbalización de una oración}
Tanto las oraciones acerca de Clases como las de Individuos requieren la verbalización de los constructores OWL. Solo en el caso de las oraciones acerca de Clases requieren además la enumeración de sus instancias, propiedades y subclases. Con enumeración de las propiedades (y de instancias y subclases por igual), nos referimos únicamente a presentarlas, por ejemplo, las propiedades \emph{tieneCobertura} y \emph{tieneBase} para la clase Pizza resultan en la oración ``una pizza tiene base de pizza y tiene cobertura de pizza''.

Las tareas necesarias para la verbalización de una oración son:
\begin{itemize}
    \item Verbalizar los constructores OWL o enumerar las propiedades, instancias y subclases.
    \item Eliminar información redundante entre oraciones a través del proceso de agragación.
    \item En el caso de las Clases, se reemplaza con expresiones de referencia a los nombres de las Clases en oraciones consecutivas evitando que se repitan y que genere un texto poco fluido.
\end{itemize}

\subsection{Sintaxis OWL 2}
\label{sec:gen_doc_sintaxis_owl}
Teniendo en cuenta la estructura jerárquica de la sintaxis (a partir de su gramática BNF y de los diagramas de clases de su documentación~\cite{OWL2W3C}), agrupamos en diferentes niveles de abstracción las tres categorías sintácticas: en el nivel inferior se encuentran las Entidades, en el nivel intermedio las Expresiones de Clases, y en el nivel superior los Axiomas. Esta separación en niveles de abstracción será útil para organizar la verbalización. El conjunto de constructores elegido para verbalizar se encuentra en las siguientes listas: en la lista~\ref{list:constructores_axiomas} se agrupan los constructores del nivel de Axiomas, en la lista~\ref{list:constructores_expresiones} los constructores de Expresiones de Clases y en la lista~\ref{list:constructores_entity} los constructores de nivel de Entidades.
\begin{figure}
\begin{multicols}{2}
\captionof{listCap}{Constructores de Entidades}
\label{list:constructores_entity}
    \begin{itemize}
        \item owl:class
        \item owl:objectProperty
        \item owl:dataProperty
        \item owl:individual
        \item[\vspace{\fill}]
    \end{itemize}

\captionof{listCap}{Constructores de Axiomas}
\label{list:constructores_axiomas}
    \begin{itemize}
        \item rdfs:subClassOf
        \item owl:equivalentClass
        \item owl:disjointWith
        \item rdfs:domain
        \item rdfs:range
    \end{itemize}
    \end{multicols}
\end{figure}


\begin{figure}
\captionof{listCap}{Constructores de Expresiones de Clase}
\label{list:constructores_expresiones}
    \begin{itemize}
    \begin{multicols}{2}
        \item owl:intersectionOf
        \item owl:unionOf
        \item owl:complementOf
        \item owl:allValuesFrom
        \item owl:someValuesFrom 
        \item owl:minCardinality
        \item owl:maxCardinality
        \item owl:Cardinality
        \item owl:oneOf
        \item owl:hasValue
        \end{multicols}
    \end{itemize}
\end{figure}

\subsection{De OWL 2 a lenguaje natural}
La verbalización de la sintaxis OWL 2 se corresponde a la tarea de traducir el lenguaje OWL al lenguaje humano. Para llevar a cabo la traducción, se tendrán en cuenta los niveles de abstracción presente en la Sección~\ref{sec:gen_doc_sintaxis_owl}. 

El enfoque adoptado para crear la sintaxis de las oraciones se basa en un recorrido bottom-up de la jerarquía de un Axioma. Se comienza desde las hojas, construyendo oraciones parciales a partir de las Entidades, luego se procede a subir por los niveles a través de los constructores de Expresiones de Clases, componiendo nuevas oraciones parciales, hasta alcanzar la raíz de la jerarquía, donde se termina de construir la oración final. Adicionalmente, se realizan algunos tratamientos morfológicos para agregar fluidez y coherencia al texto, tal como insertar artículos, y hacer concordar los sustantivos en género y número.

Con el objetivo de comenzar a formar las oraciones parciales, el primer paso a realizar es verbalizar las Entidades, ya que están directamente relacionadas con las IRIs (o tienen acceso al \emph{label}, en caso de extraer los nombres desde los \emph{labels}).

En la Gramática~\ref{gram:entity} se muestra una porción de la gramática BNF del lenguaje OWL 2 asociada a las Entidades.
\begin{GrammarEnv}
%detecta un error de sintaxis pero es mentira.
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
%<expression> : <number> ; <number>, [\{"asd"\}], <relational\_operator>, <number>.
%<number> : <digit> ; <digit> , <number>.
%<digit> : "0";"1";"2";"3";"4";"5";"6";"7";"8";"9".
%<relational\_operator> : $"="$;"$\lessthan \greaterthan$";"$\lessthan$";"$\greaterthan$"; "$\lessthan=$";"$\greaterthan=$";"in".
\fbox{\begin{minipage}{14cm}
<Entity> : <Class> ; <ObjectProperty> ; <DataProperty> ; <NamedIndividual> ; <AnnotationProperty>.
<Class> : <IRI> .
<ObjectProperty> : <IRI> .
<DataProperty> : <IRI> .
<AnnotationProperty> : <IRI> .
<NamedIndividual> : <IRI> .
\end{minipage}
}
\end{grammar}
\caption{Porción de gramática asociada a las Entidades.}\label{gram:entity}
\end{GrammarEnv}

En el siguiente nivel se tienen los constructores de Expresiones de Clase, con las cuales es posible generar oraciones complejas subordinando las expresiones que se encuentran anidadas, o componer nuevas oraciones parciales teniendo en cuenta los tipos de componentes involucrados.

En la Gramática~\ref{gram:expr_clases} se muestra a modo de ejemplo una sección de la gramática con constructores de este nivel.
\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
%<expression> : <number> ; <number>, [\{"asd"\}], <relational\_operator>, <number>.
%<number> : <digit> ; <digit> , <number>.
%<digit> : "0";"1";"2";"3";"4";"5";"6";"7";"8";"9".
%<relational\_operator> : $"="$;"$\lessthan \greaterthan$";"$\lessthan$";"$\greaterthan$"; "$\lessthan=$";"$\greaterthan=$";"in".
\fbox{\begin{minipage}{14cm}
<ClassExpression> : <Class> ; <ObjectIntersectionOf> ; <ObjectSomeValuesFrom> .
<ObjectSomeValuesFrom> : "ObjectSomeValuesFrom" "(" <ObjectPropertyExpression> <ClassExpression> ")" .
<ObjectPropertyExpression> : <ObjectProperty> .
\end{minipage}}
\end{grammar}
\caption{Porción de gramática asociada a las Expresiones de Clases.}\label{gram:expr_clases}
\end{GrammarEnv}

Puede apreciarse en la gramática que existe recursividad entre los constructores, lo que produce que un constructor aparezca en diferentes niveles y pueda combinarse con cualquier otro constructor del nivel de Expresiones de Clases. En este punto es importante que cada constructor pueda componerse con los demás, para asegurar cualquier combinación posible.

Por último en el nivel más abstracto se encuentran los constructores de Axiomas. Estos constructores tienen la característica de no ser recursivos entre ellos, por lo que es posible generar oraciones independientes, yuxtapuestas o coordinadas. Un ejemplo de estos constructores se ve en la Gramática~\ref{gram:axiom}.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
%<expression> : <number> ; <number>, [\{"asd"\}], <relational\_operator>, <number>.
%<number> : <digit> ; <digit> , <number>.
%<digit> : "0";"1";"2";"3";"4";"5";"6";"7";"8";"9".
%<relational\_operator> : $"="$;"$\lessthan \greaterthan$";"$\lessthan$";"$\greaterthan$"; "$\lessthan=$";"$\greaterthan=$";"in".
\fbox{\begin{minipage}{14cm}
<ClassAxiom> : <SubClassOf> ; <EquivalentClasses> ; <DisjointClasses> ; <DisjointUnion> .
<EquivalentClasses> : "EquivalentClasses" "(" <axiomAnnotations> <ClassExpression> <ClassExpression> \{ <ClassExpression> \} ")".
\end{minipage}}
\end{grammar}
\caption{Porción de gramática asociada a los Axiomas.}\label{gram:axiom}
\end{GrammarEnv}

\subsection{Componentes y oraciones parciales}
Durante la creación de una oración, se recorren los constructores de Expresiones de Clases y de Entidades, creando oraciones parciales y componiéndolas entre ellas. Dado que cada constructor puede componerse con cualquier otro y en cualquier nivel de profundidad, se decidió asociar a cada constructor un tipo de componente oracional, de esta manera se evita una exhaustiva programación de composiciones.
Los tipos de componentes son los siguientes:
\begin{itemize}
    \item Término (T): caracterizado por no poseer verbo. Pueden contener adverbios, sustantivos y adjetivos.
    \item Sintagma Verbal (SV): debe poseer un verbo.
    \item Oración Negativa (ON): representa la negación de un componente.
    \item Unión: representa una disyunción de oraciones parciales.
    \item Intersección: representa una adición o subordinación de oraciones parciales.
\end{itemize}

Estos tipos de componentes definen un sistema de tipos, en el que cada tipo puede componerse con otro y dan como resultado un nuevo componente. La particularidad de este sistema es que el tipo de una composición no depende de sus componentes, sino del constructor que opere con esos componentes.
%En la mayoría de los casos el tipo de componente es predecible, a excepción de la \emph{intersección}.

Los componentes que retorna cada constructor se definen a continuación:
\begin{itemize}
    \item Componente Término (T):
    \begin{itemize}
        \item Clase.
        \item Individuo
    \end{itemize}
    \item Componente Sintagma Verbal (SV):
    \begin{itemize}
        \item Propiedad.
        \item Constructores de cuantificación.
        \item Constructor \emph{hasValue}.
        \item Constructores con cardinalidad.
    \end{itemize}
    \item Componente Union: 
    \begin{itemize}
        \item \emph{UnionOf}.
        \item \emph{OneOf}
    \end{itemize}
    
    \item Componente Intersección: solo el constructor \emph{IntersectionOf}.
    \item Componente Oración Negativa (ON): solo el constructor \emph{ComplementOf}.
\end{itemize}

El beneficio de este sistema es que cada constructor sabe cómo realizar la composición, en función del tipo de cada uno de sus operandos, lo que reduce la cantidad de combinaciones a programar (en contraste con tener que programar el proceso de composición de cada constructor teniendo en cuenta que sus operandos serían otros constructores en lugar de componentes). 

Además, incorporar un sistema como este, evita el uso de otras técnicas menos afines a la lingüística, como \emph{templates} prediseñados o texto genérico para cada caso particular, ya que se basa en el uso de patrones más cercanos a la Lingüística Teórica, apoyando el uso de teorías lingüísticas en el campo del Procesamiento de Lenguaje Natural.


Sin embargo, estos componentes no intentan ser exhaustivos ni completamente fieles a la sintaxis del lenguaje humano, sino que intentan acaparar de la forma más general los posibles resultados de cada constructor, para mantener una sintaxis sencilla y aceptable. Una Clase, por ejemplo, podría cumplir la función de sintagma nominal, adjetival o adverbial, pero para simplificar la nomenclatura, se retorna un tipo más genérico y al momento de usar una Clase, de ser necesario, se resuelve la composición en función de los elementos que la constituyen. Como veremos más adelante, a veces es innecesario discriminar los tipos de sintagmas.


\subsection{Convención y suposiciones del nombrado de Entidades}
Para no limitar la aplicación a una convención de nombrado, no se requiere una forma estricta para nombrar las entidades en una ontología. Sin embargo, nos basamos en algunas suposiciones que resultan natural al crear una ontología:
\begin{enumerate}
    \item Las entidades pueden tener su nombre ya sea en la IRI o en un label\footnote{Estas opciones son excluyentes, al verbalizar una ontología solo se extraen los nombres de un solo lugar, por lo que todos los nombres deben ser extraídos de IRI o de label sin combinarse}. Si el nombre es extraído de una IRI, debe estar escrito con el estilo CamelCase. Si el nombre se extrae de un label, debe estar escrito en lenguaje natural, y debe tener el idioma del label (en este caso, español ``es'' o ingles ``en'').
    \item No hay condiciones para el nombre de una clase, sin embargo es preferible que contenga al menos un sustantivo.
    \item No hay condiciones para el nombre de una propiedad, sin embargo es preferible que contenga al menos un verbo. 
    
    No se infieren verbos, por lo que si se quiere expresar, por ejemplo, que una clase \emph{está localizada en} algún lugar, la propiedad debería llamarse \emph{estáLocalizadaEn} y no \emph{localizadaEn}. Al igual que los verbos, no es conveniente omitir las preposiciones finales, por ejemplo, en la propiedad \emph{esParte}, es recomendable utilizar \emph{esParteDe}.
\end{enumerate}

Estas condiciones ayudan a mejorar la fluidez del texto y no suponen una gran carga en los desarrolladores de ontologías.


\subsection{Tratamiento sintáctico de los nombres de Entidades}
Para facilitar el entendimiento de las secciones referidas al micro planning, se explicará cómo fueron tratados los nombres de las entidades, desde el punto de vista sintáctico. 

Dado que los nombres de las Entidades pueden no corresponderse fielmente con la gramática de un lenguaje (por falta de palabras funcionales, tales como artículos o preposiciones), se optó por no realizar un análisis sintáctico a los nombres. Sin embargo, para soportar la creación de patrones gramaticales, se etiquetaron las palabras de cada Entidad para reconocer la función gramatical de cada una y poder llevar a cabo las composiciones.

Se consideró, a cada conjunto de palabras que conforman el nombre de una entidad, como un componente incompleto (oración parcial) que es parte de una oración más grande. Por este motivo, se divide en dos partes fundamentales: una parte inicial y un complemento, entre los cuales pueden insertarse nexos y cuantificaciones. A continuación se explican cómo se reconocen ambas partes en las clases y propiedades:
\begin{itemize}
    \item Los nombres de las propiedades (en los que suponemos existe al menos un verbo), se considera como parte inicial a todas las palabras desde el inicio hasta el primer verbo, incluído el verbo. El complemento se conforma con todas las palabras que siguen al verbo. Por ejemplo: la propiedad \emph{tiene color} se compone de parte inicial: \emph{tiene}, y complemento: \emph{color}. La propiedad \emph{se solapa con} se compone de \emph{se solapa} como parte de inicial, y \emph{con} como complemento.
    \item Los nombres de las clases (en los que suponemos existe al menos un sustantivo), se considera como parte inicial a todas las palabras desde el inicio hasta el primer sustantivo, incluido el sustantivo. El complemento se conforma con todas las palabras que siguen al sustantivo. Por ejemplo: la clase \emph{agente social}, tiene como parte inicial \emph{agente} y complemento \emph{social}. La clase \emph{cobertura de pizza} se compone de \emph{cobertura} con complemento \emph{de pizza}.
    \item Los nombres de los individuos son tratados igual que los nombres de las clases.
\end{itemize}


\subsection{Verbalización de constructores OWL}
\label{sec:verbalizacion_constructores}
Esta tarea se encarga de componer las oraciones según la información de cada constructor OWL.
%Las oraciones pueden enfocarse ya sea en una \emph{owl:Class} o  \emph{owl:NamedIndividual}. Cuando se enfocan en una \emph{owl:Class}, pueden contener la siguiente información: clases equivalentes, disjuntas y superclases. Cuando se enfoca en un \emph{owl:NamedIndividual}, puede contener información acerca de los valores de sus propiedades.
%Para cada uno de estos tipos de información, se pueden presentar una o varias oraciones. Las oraciones que tratan el mismo tipo de información se organizan adyacentemente entre ellas.
En algunos constructores, tener un único patrón gramatical resulta insuficiente, debido a que pueden recibir distintas estructuras gramaticales como entrada, que requieren diferentes formas de componerse. Por lo tanto, en estos casos se diseñó más de una forma de composición, mejorando la variabilidad, fluidez e interpretación de las oraciones. 

Para reconocer cómo componer las oraciones en cada constructor, se revisó empíricamente los axiomas de algunas ontologías, y se buscó utilizar oraciones que sean lo más genéricas posibles, que permitan la comprensión de los axiomas. 

A continuación se explican los patrones gramaticales usados para cada constructor. %El signo $+$ corresponde a la concatenación de cadenas de texto.

\subsubsection{Restricción de cardinalidad \emph{ObjectCardinalityRestriction}}

La gramática~\ref{gram:object_card_rest} muestra los patrones diseñados para las restricciones de cardinalidad sobre \emph{objectProperty}. En los casos donde sea posible, si la clase sobre la que se aplica la restricción es \emph{owl:Thing}, se reemplaza por el rango de la propiedad, el complemento de la propiedad (como el patron$_2$) o por último por la palabra ``cosa''.

El enlace es seleccionado dependiendo del operador \emph{MinCardinality}, \emph{MaxCardinality} y \emph{ExactCardinality}.

Ejemplo: para la clase ``pizza interesante'', se tiene el axioma: ``tieneCobertura min 3 owl:Thing'', que puede verbalizarse como ``tiene como mínimo 3 coberturas de pizza''. La parte de la oración que se corresponde a \emph{coberturas de pizza}, es extraída del rango de la propiedad.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionCard> : <patron$_1$> ; <patron$_2$> ; <patron$_3$>.
<patron$_1$> : <parteInicialPropiedad> <complementoPropiedad> <enlace> <cardinalidad> <clases> .
<patron$_2$> : <parteInicialPropiedad> <enlace> <cardinalidad> <complementoPropiedad>.
<patron$_3$> : <parteInicialPropiedad> <enlace> <cardinalidad> <rangoPropiedad>.
<patron$_4$> : <parteInicialPropiedad> <enlace> <cardinalidad> <clases>.
<enlace> : "como mínimo" ; "como máximo"; "exactamente".
\end{minipage}}
\end{grammar}
\caption{Patrones para ObjectCardinalityRestriction.}\label{gram:object_card_rest}
\end{GrammarEnv}

\subsubsection{Restricción de cardinalidad \emph{DataCardinalityRestriction}}
La gramática~\ref{gram:data_card_rest} muestra los patrones diseñados para las restricciones de cardinalidad sobre \emph{dataProperty}. El patron$_2$ es específico para cuando la propiedad no tiene verbo. 

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionCard> : <patron$_1$> ; <patron$_2$>.
<patron$_1$> : <parteInicialPropiedad> <enlace> <cardinalidad> <complementoPropiedad> .
<patron$_2$> : "tiene" <enlace> <cardinalidad> <nombrePropiedad>.
<enlace> : "al menos" ; "como máximo"; "exactamente".
\end{minipage}}
\end{grammar}
\caption{Patrones para DataCardinalityRestriction.}\label{gram:data_card_rest}
\end{GrammarEnv}

\subsubsection{Restricción de cuantificación \emph{QuantifiedObjectRestriction}}
La gramática~\ref{gram:quant_obj_rest} muestra los patrones diseñados para las cuantificaciones sobre \emph{objectProperty}.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionQuant> : <patron$_1$> ; <patron$_2$> ; <patron$_3$> ; <patron$_4$> ; <patron$_5$> .
<patron$_1$> : <verboPropiedad> "como" <complementoPropiedad> <enlace> <clases> .
<patron$_2$> : <verboPropiedad> <enlace> <clases> .
<patron$_3$> : <verboPropiedad> <enlace> "a" <clases> .
<patron$_4$> : <verboPropiedad> "a" <enlace> <clases> .
<patron$_5$> : <verboPropiedad> <complementoPropiedad> <enlace> <clases> .
<enlace> : "algún" ; "alguna"; "algo"; "exclusivamente" .
\end{minipage}}
\end{grammar}
\caption{Patrones para QuantifiedObjectRestriction.}\label{gram:quant_obj_rest}
\end{GrammarEnv}

Los enlaces dependen del tipo de cuantificador y del tipo de palabra que lo proceda. Si el cuantificador es existencial, el enlace sería ``alguna/algún'' para palabras que sean sustantivo femenino o masculino respectivamente, o con cualquier otra palabra sería ``algo''.  Para el cuantificador universal el enlace es siempre ``exclusivamente''.

Ejemplo: la clase ``Margherita'' que es subclase de ``PizzaConNombre'', tiene el axioma ``tieneCobertura only 
    (CoberturaDeMozzarella or CoberturaDeTomate)'' (siendo only el cuantificador universal), el cual se traduce a ``tiene cobertura de mozzarella o tomate''. También posee dos axiomas equivalentes al anterior: ``tieneCobertura some CoberturaDeMozzarella'' y ``tieneCobertura some CoberturaDeTomate'', (siendo some el cuantificador existencial), los cuales se traducen a ``tiene alguna cobertura de mozzarella'' y ``tiene alguna cobertura de tomate''.


\subsubsection{Restricción de cuantificación \emph{QuantifiedDataRestriction}}
La gramática~\ref{gram:quant_data_rest} muestra los patrones diseñados para las cuantificaciones sobre \emph{dataProperty}.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionQuant> : <patron$_1$> ; <patron$_2$> .
<patron$_1$> : <verboPropiedad> <enlace> <complementoPropiedad> "de tipo" <rangoPropiedad> .
<patron$_2$> : <verboPropiedad> <complementoPropiedad> <enlace> "de tipo" <rangoPropiedad> .
<enlace> : "algún" ; "alguna"; "algo"; "exclusivamente" .
\end{minipage}}
\end{grammar}
\caption{Patrones para QuantifiedDataRestriction.}\label{gram:quant_data_rest}
\end{GrammarEnv}

\subsubsection{Restricción \emph{OWLObjectComplementOf}}
La gramática~\ref{gram:complement_rest} muestra los patrones diseñados para el complemento de una Expresión de Clase.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionComplement> : <patron$_1$>.
<patron$_1$> : <enlace> <clase> .
<enlace> : "lo opuesto de" ; "no"; "ni"; "excepto" .
\end{minipage}}
\end{grammar}
\caption{Patrones para OWLObjectComplementOf.}\label{gram:complement_rest}
\end{GrammarEnv}

\subsubsection{Restricción \emph{OWLObjectInverseOf}}
La gramática~\ref{gram:inverse_rest} muestra los patrones diseñados para el inverso de una Propiedad.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionInverse> : <patron$_1$>.
<patron$_1$> : <enlace> <Propiedad> .
<enlace> : "es lo opuesto de" .
\end{minipage}}
\end{grammar}
\caption{Patrones para OWLObjectInverseOf.}\label{gram:inverse_rest}
\end{GrammarEnv}

\subsubsection{Restricción \emph{OWLObjectHasValue}}
La gramática~\ref{gram:hasvalue_rest} muestra los patrones diseñados para los valores de una Propiedad.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionHasValue> : <patron$_1$> ; <patron$_2$>.
<patron$_1$> : <parteInicialPropiedad> <complementoPropiedad> <Individuo>.
<patron$_2$> : <parteInicialPropiedad> <Individuo> .
\end{minipage}}
\end{grammar}
\caption{Patrones para OWLHasValue.}\label{gram:hasvalue_rest}
\end{GrammarEnv}

\subsubsection{Restricción \emph{OWLObjectHasSelf}}
La gramática~\ref{gram:hasself_rest} muestra los patrones diseñados para una auto restricción de una Propiedad sobre sí misma.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<RestriccionHasSelf> : <patron$_1$>.
<patron$_1$> : <parteInicialPropiedad> <complementoPropiedad> "Sí MISMO".
\end{minipage}}
\end{grammar}
\caption{Patrones para OWLObjectHasSelf.}\label{gram:hasself_rest}
\end{GrammarEnv}


\subsubsection{Restricción N-Ary \emph{UnionOf} y \emph{oneOf}} 
Como representan una secuencia de elementos, en la que uno o más elementos pueden ser verdaderos, se eligió concatenar a todos los elementos con el conector disyuntivo ``o''. Sean e1, e2,...,eN los elementos de la enumeración, el patrón gramatical elegido es: ``e1, e2, ..., eN-1 \emph{o} eN''.

\subsubsection{Restricción N-Ary \emph{InterseccionOf}}
La intersección da lugar tanto a la adición como a la subordinación de oraciones. Antes de verbalizar una intersección, se ordenan sus componentes de mayor a menor prioridad, teniendo en cuenta que: T, ON, Unión, Intersección tienen la misma prioridad, y SV tiene menor prioridad. 

Para determinar cómo verbalizar una intersección, se tienen en cuenta las siguientes condiciones:
\begin{itemize}
    \item Si la intersección tiene dos operandos:
        \begin{itemize}
            \item Si el primero es de tipo T  y el segundo SV, se subordina la segunda oración de la siguiente manera:
            ``contenido primer operando + ``que'' + contenido segundo operando''
            \item en cualquier otro caso, se coordinan los operandos:
            ``contenido primer operando + ``y'' + contenido segundo operando''
        \end{itemize}
        \item Si la intersección tiene más de dos operandos, se agrupan según el tipo  (T, SV, ON) y luego se coordinan con la conjunción ``y''.
\end{itemize}

Ejemplo, el axioma de clase equivalente ``Pizza and (tieneCobertura some (CoberturaDePizza and (tienePicante some MuyPicante)))'' de la clase pizzaPicanteEquivalente, contiene dos intersecciones las cuales poseen los mismos componentes: T$+$SV, por lo que utilizamos el conector ``que'' para subordinar el segundo operando. Con este criterio, el axioma anterior sería ``pizza picante es una pizza \emph{que} tiene alguna cobertura de pizza \emph{que} tiene algún picante muy picante''.

En caso de asociar la intersección al conector \emph{y} sin tener en cuenta el contexto, se generaría una oración como la siguiente ``pizza picante es una pizza \emph{y} tiene alguna cobertura de pizza \emph{y} tiene algo muy picante'', dando lugar a ambigüedad, pues la segunda ``y'' podría cumplir la función de adición, interpretándose que la pizza tiene algo picante, en lugar de cumplir una función de subordinación, donde la interpretación correcta es que la cobertura de la pizza es picante. 

\subsection{Enumeración de propiedades, subclases e individuos}
Enumerar esta información es solo para anunciar la existencia de estos componentes, por lo que la sintaxis es simple.

Para las subclases se creó el patrón de la Gramática~\ref{gram:subclases}.
Para los individuos se creó un patrón similar al de las subclases.
Para las propiedades se creó el patrón de la Gramática~\ref{gram:propiedades}.

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<EnumerarSubclases> : <patron$_1$> ; <patron$_2$>.
<patron$_1$> : "existen las siguientes clases de" <topico> "$\colon$" <subclases>.
<patron$_2$> : <subclase> "es la única clase de" <topico>.
\end{minipage}}
\end{grammar}
\caption{Patrones para enumerar subclases.}\label{gram:subclases}
\end{GrammarEnv}

\begin{GrammarEnv}
\begin{grammar}
[(colon){$\rightarrow$}]
[(semicolon)$|$]
[(comma){}]
[(period){\vspace{0.3cm} \\}]
[(quote){\begin{bf}}{\end{bf}}]
[(nonterminal){$<$}{$>$}]
\fbox{\begin{minipage}{14cm}
<EnumerarPropiedades> : <patron$_1$> ; <patron$_2$> ; <patron$_3$>.
<patron$_1$> : <parteInicialPropiedad> <complementoPropiedad> <rangoPropiedad> .
<patron$_2$> : <parteInicialPropiedad> "como" <complementoPropiedad> "a" <rangoPropiedad> .
<patron$_3$> : <parteInicialPropiedad> <rangoPropiedad> .
\end{minipage}}
\end{grammar}
\caption{Patrones para enumerar propiedades.}\label{gram:propiedades}
\end{GrammarEnv}



\subsection{Expresiones de referencia}
El proceso de referenciación se ve facilitado por el uso de la Teoría de Centrado. 
Teniendo en cuenta que cada párrafo (y por lo tanto cada oración que lo compone) trata centralmente una única Clase o Individuo, no se intercalan tópicos como focos de atención, por lo que se reduce la posibilidad de ambigüedad. Las expresiones de referencia solo fueron implementadas para las Clases.

Para llevar a cabo la referenciación, se tuvo en cuenta el uso de pronombres demostrativos (``este/esta''), a veces, acompañados por el primer sustantivo (si posee) del nombre de la Clase. Por ejemplo: sean las oraciones ``Una Rosa es una pizza con nombre. Una Rosa tiene como cobertura a alguna cobertura de gorgonzola, mozzarella Y tomate.'' en la segunda oración en lugar de repetir ``una Rosa'', se reemplaza por una expresión de referencia ``Una Rosa es una pizza con nombre. \emph{esta} tiene como cobertura a alguna cobertura de gorgonzola, mozzarella Y tomate.''. Otro ejemplo en el que el pronombre es acompañado por el sustantivo de la Clase es: ``una cobertura de salsa de chile tabasco es una cobertura de salsa. \emph{Esta cobertura} tiene como picante algo muy picante.''

%Otro tipo de referencias, se da en el momento de explicar una clase. Cuando se crea una sección hablando acerca de una clase \emph{A}, esa sección no vuelve a crearse si existe una clase \emph{B} cuya descripción requiere que se explique la clase \emph{A}, sino que en la clase \emph{B} se hace referencia a la sección donde ya fue explicada la clase \emph{A}. Esto permite reutilizar las secciones y evita agregar información redundante en el texto.

\subsection{Agregación de sentencias}
La agregación de sentencias ocurre en dos lugares. Uno es durante el proceso de producción de una oración en el constructor \emph{N-Ary}, es decir dentro de una oración; el otro es durante el proceso de creación de párrafos, es decir, entre oraciones.

%de marco metodologico para la gnl
Basaremos la agregación en la conjunción por componentes compartidos~\cite{bernardos2003marco}. El objetivo es que los elementos en común aparezcan una sola vez, mediante elipsis del componente repetido, por ejemplo: sean las oraciones: ``la casa tiene color rojo'', ``la casa tiene color azul'' y ``la casa tiene color verde'', al comparar linealmente las oraciones, se elimina de las consecutivas oraciones la parte inicial que tengan en común. El resultado de esta agregación es: ``la casa tiene color rojo, azul y verde''.
    
\begin{itemize}
    \item {\bf Agregación en constructor NAry}: en las situaciones en las que este constructor se utiliza para enumerar sentencias, como el orden de los elementos enumerados no altera el significado de la oración, se optó por agrupar los elementos según su función (T, SV, ON). Para el grupo de sentencias T, se omitió información inicial de cada sentencia. Por ejemplo: las oraciones ``pizza con carne'', ``pizza picante'' y ``pizza no vegetariana'', se convierten en la oración ``pizza con carne, picante y no vegetariana''.
    
    Para los grupos SV y ON, se ordenaron por verbo, y cada verbo aparece una sola vez, acompañado por la enumeración de los complementos de cada elemento. Por ejemplo: las oraciones ``no tiene como cobertura alguna cobertura de carne'' y ``no tiene como cobertura alguna cobertura de pescado'' se convierten en ``no tiene como cobertura alguna cobertura de carne ni pescado''.
    
    \item {\bf Agregación entre sentencias}: esta agregación se aplica cuando se recorren las sentencias para armar un párrafo. Además de agrupar las sentencias por función (T, SV, ON), también se separan por constructor, obteniendo así 8 grupos: \emph{ObjectSomeValuesFrom, ObjectAllValuesFrom, intersection, union, ObjectHasValue, T, ON y SV}. De esta manera, para cada grupo, se realiza la agregación, de manera independiente entre ellos.
\end{itemize}

\subsection{Ejemplos verbalización de Axiomas}
Con el objetivo de mostrar el proceso de verbalización de forma intuitiva, se representó la composición de oraciones parciales de forma gráfica usando árboles. Se tomaron dos ejemplos de Axiomas de dos ontologías diferentes, uno en lenguaje español y el otro en inglés.

Para no sobrecargar la imagen, se omitió información de menor importancia, como el resultado de verbalizar una Entidad en los nodos hojas, ya que es el mismo nombre de la Entidad pero sin la nomenclatura CamelCase; y se omitió la información gramatical de cada palabra.

\subsubsection{Ejemplo verbalización lenguaje español}
El ejemplo se tomó de la ontología Pizza. El Axioma se corresponde al constructor \emph{owl:equivalentClass} sobre la clase \emph{PizzaPicanteEquivalente}. El contenido del axioma es el siguiente: 
\begin{verbatim}
EquivalentClasses(
    :PizzaPicanteEquivalente
    ObjectIntersectionOf(
        :Pizza
        ObjectSomeValuesFrom(
            :tieneCobertura
            ObjectIntersectionOf(
                :CoberturaDePizza
                ObjectSomeValuesFrom(
                    :tienePicante
                    :MuyPicante)
            )
        )
    )
)    
\end{verbatim}
La verbalización se muestra en la figura~\ref{fig:ejemplo_verb_espaniol}.

Los pasos del proceso se encuentran enumerados desde el 1 al 6. La verbalización comienza en la parte más profunda del árbol, y a medida que se generan las oraciones parciales se retornan al nivel superior del árbol para continuar la composición.

Las composiciones se resuelven a través de las Gramáticas de la sección~\ref{sec:verbalizacion_constructores}. Por ejemplo, en el paso Nº1 utiliza patron$_1$ de la Gramática~\ref{gram:quant_obj_rest}, donde:
\begin{itemize}
    \item $<$verboPropiedad$>$ es ``tiene''.
    \item $<$complementoPropiedad$>$ es ``picante''.
    \item $<$enlace$>$ es ``algún''.
    \item $<$clases$>$ es ``muy picante''.
\end{itemize}

En el paso Nº2, como es una intersección de dos operandos, utiliza la subordinación de SV respecto a T.

De esta manera, en cada nivel busca utilizar un patrón que se ajuste a los componentes recibidos.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/generacion_documento/verbalizacion_equivalentClass_spanish.pdf}
    \caption{Ejemplo gráfico de verbalización en lenguaje español.}
    \label{fig:ejemplo_verb_espaniol}
\end{figure}

\subsubsection{Axioma lenguaje inglés}
El ejemplo se tomó de la ontología Wine. El Axioma se corresponde al constructor \emph{owl:equivalentClass} sobre la clase \emph{CheninBlanc}. El contenido del axioma es el siguiente: 

\begin{verbatim}
EquivalentClasses(
    :CheninBlanc
    ObjectIntersectionOf(
        :Wine
        ObjectHasValue(
            :madeFromGrape
            :CheninBlancGrape)
        ObjectMaxCardinality(
        1
        :madeFromGrape)
    )
)
\end{verbatim}
La verbalización se muestra en la figura~\ref{fig:ejemplo_verb_ingles}.

Los pasos del proceso se encuentran enumerados desde el 1 al 4. Las gramáticas utilizadas son similares a las explicadas para lenguaje español, con la diferencia que los enlaces han sido traducidos a inglés.

Resulta conveniente explicar el paso Nº3 particularmente. El resultado de este paso es consecuencia de la intersección entre ``Wine'' y el resultado del paso 1 y 2. 
Como es una intersección de tres componentes, se procede a agrupar los componentes según su tipo, para luego unirlos a través de la conjunción ``y''. Dado que el operador \emph{hasValue} y \emph{minCardinality} retornan componentes de tipo SV, son agrupados juntos en una oración. Luego de agruparlos, se procede a realizar el proceso de agregación entre ambas, a través del cual se elimina el verbo ``made'' de la oración parcial construida en el paso 1. 

Por otro lado, la Clase Wine retorna un tipo T, por lo que queda aislado en una oración independiente. Estas agrupaciones resultan en el texto del paso Nº3.

La verbalización de este axioma da como resultado dos oraciones. Como ambas oraciones hacen referencia a la misma Clase, en el paso Nº4 ocurre un reemplazo del nombre de la Clase por una Expresión de Referencia en la segunda oración. 

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/generacion_documento/verbalizacion_equivalentClass_english.pdf}
    \caption{Ejemplo gráfico de verbalización en lenguaje inglés.}
    \label{fig:ejemplo_verb_ingles}
\end{figure}

\subsection{Diagrama de clases}
En la figura \ref{fig:diagrama_clases_microplanificador} se puede ver el diagrama de clases asociado al módulo de Micro Planificación. 

La clase \emph{Statement} es la encargada de realizar la verbalización de los constructores de Axiomas y las enumeraciones. Un objeto \emph{Statement} puede generar más de una oración, ya que cada \emph{Statement} trata un solo tópico y un solo tipo de constructor, pero pueden haber varios axiomas que utilicen el mismo tipo de constructor, por lo que todos esos axiomas estarán en la misma \emph{Statement}.

La clase \emph{StatementComponent} representa la oraciones parciales. Se encarga de componer oraciones parciales y generar una nueva oración parcial. En el caso de un constructor de Entidad, se encarga de generar una oración parcial compuesta por el nombre de la Entidad.

La clase \emph{Word} representa las palabras usadas durante la verbalización. Contiene la función gramatical de la palabra, y los algoritmos necesarios para convertir una palabra en plural, un número en palabra (1 a uno), cambiar el género de una palabra, retornar el artículo correspondiente a un sustantivo, entre otros.

Las subclases de \emph{OWLRestriction} tienen la capacidad de verbalizar los constructores de Expresiones de Clases y de generar las \emph{StatementComponent}.

\begin{figure}[H]
    \centering
    \includegraphics{img/generacion_documento/diagrama_clases_microplanificador.pdf}
    \caption{Diagrama de clases del Micro Planificador.}
    \label{fig:diagrama_clases_microplanificador}
\end{figure}


\section{Implementación Micro Planning}
Para facilitar la implementación de los algoritmos de Agregación y Expresiones de Referencia, decidimos implementar el contenido de las oraciones con listas de palabras en lugar de cadenas de texto, facilitando su manipulación y recorrido. De esta manera, se creó la interfaz \emph{Word} con sus respectivas subclases \emph{WordEnglish} y \emph{WordSpanish}. 
La clase \emph{WordSpanish} utiliza la librería \emph{javaGramatica}\footnote{\url{https://www.proinf.net/permalink/gramatica_numero_genero_y_acentuacion}}, para implementar algunos métodos del idioma español, como pluralizar, cambio de género, número, etc. Para el idioma inglés estos métodos fueron implementados manualmente.

Cada vez que se crea una Word, debe especificarse su palabra y el tipo de función que cumple la palabra. Para identificar el tipo de una palabra, se utilizó el software\texttt{Stanford POS Tagger}\footnote{https://nlp.stanford.edu/software/tagger.html}, el cual permite etiquetar palabras de inglés, español y otros idiomas. Este software utiliza una nomenclatura específica para etiquetar las palabras, por lo que utilizamos esa nomenclatura y la implementamos a través de Variables de Clase creadas en la clase Word.

Los objetos \emph{Word} son creados por cada \emph{StatementComponent}. Una \emph{StatementComponent} se crea durante el proceso de verbalización de los constructores de Expresiones de Clase y de Entidades. Como los constructores del nivel más bajo son de Entidades, es en ellas donde se decide qué tipo de objeto se instancia según el idioma, es decir \emph{StatementComponentEnglish} o \emph{StatementComponentSpanish}. 

En el nivel de los constructores de Expresiones de Clase se encuentran las clases que heredan de la interfaz \emph{OWLRestriction}. Esta interfaz acopla los atributos que requieren los constructores, como los individuos, las clases, las propiedades y cardinalidades.

Las clases que implementan \emph{OWLRestriction} componen y generan las \emph{StatementComponent}. Como ejemplo, se muestra en la Figura~\ref{fig:clase_OWLObjectComplementOf} la implementación de la clase \emph{OWLObjectComplementOf} con los métodos para implementar la verbalización del constructor en español.

Se puede ver que el método \emph{generateStatementSpanish()} recibe como párametro un objeto de clase \emph{TextCotext}. Esta clase tiene el tópico al que hace referencia la oración que se está componiendo y el lenguaje de la oración, para ser utilizados, por ejemplo, en la generación de Expresiones de Referencia.

Por último la interfaz \emph{Statement} tiene los atributos necesarios para que sus implementaciones \emph{StatementEnglish} y \emph{StatementSpanish} puedan verbalizar los constructores de Axiomas y de unir todas las oraciones. 

Las \emph{Statement} utilizan la Agregación y las Expresiones de Referencia cuando generan varias oraciones. Estas tareas se implementaron en las clases \emph{StatementComponent} (teniendo en cuenta sus implementaciones) y \emph{OWLClass} respectivamente. 

\begin{figure}
\begin{minted}[autogobble,linenos]{java}
public class OWLObjectComplementOf extends OWLRestriction{

    public OWLObjectComplementOf(String type, String lang) {
        super(type, lang);
    }

@Override
    protected StatementComponent generateStatementSpanish(TextCotext c) {
        LinkedList<StatementComponent> stmsClasses = new LinkedList<>();
        stmsClasses.add(classes.get(0).generateStatement(c));
        LinkedList<Word> resList = new LinkedList<>();
        LinkedList<Word> enlace = getEnlaceSpanish(stmsClasses.get(0));
        resList.addAll(enlace);
        resList.addAll(stmsClasses.get(0).getListWords());
        StatementComponent stm = new StatementComponentSpanish(c, resList, "ON", type);
        stm.setComplementList(resList);
        return stm;
    }
    
    private LinkedList<Word> getEnlaceSpanish(StatementComponent stm) {
        LinkedList<Word> enlace = new LinkedList<>();
        if (stm.getType().equals("T")) {
            WordSpanish lo = new WordSpanish("LO", WordSpanish.TYPE_PRONOUN);
            WordSpanish opuesto = new WordSpanish("OPUESTO", WordSpanish.TYPE_ADJETIVE);
            WordSpanish de = new WordSpanish("DE", WordSpanish.TYPE_PREPOSITION);
            enlace.add(lo);
            enlace.add(opuesto);
            enlace.add(de);
        } else if (stm.getType().equals("SV")) {
            WordSpanish no = new WordSpanish("NO", WordSpanish.TYPE_ADV_NEG);
            enlace.add(no);
        } else if (stm.getType().equals("ON")) {
            WordSpanish ni = new WordSpanish("NI", WordSpanish.TYPE_CONJUNTION_COORD);
            enlace.add(ni);
        }else {
            WordSpanish no = new WordSpanish("EXCEPTO", WordSpanish.TYPE_ADV_NEG);
            enlace.add(no);
        }
        return enlace;
    }
}
\end{minted}
\caption{Implementación de los métodos para verbalizar el constructor \emph{OWLObjectComplementOf} en español.}
\label{fig:clase_OWLObjectComplementOf}
\end{figure}

\section{Diseño del realizador}
%La arquitectura de este trabajo relegó la tarea de definir la estructura de las oraciones y llevar acabo su realización lingüística a la etapa de Micro Planning.
En esta etapa queda la tarea de definir la estructura final del documento. 

Alcanzaremos el Documento Final, a través del refinamiento del Documento Inicial creado en el Macro Planning.

El Documento Inicial tiene una estructura en la que todos los tópicos tienen su propia sección, por lo que no existe más información que haga posible expandir la estructura. Por este motivo, nos enfocaremos en la idea de reducir la estructura del documento convirtiendo secciones en párrafos, para que se haga más compacto, tratando de mejorar la estética y el proceso de lectura, sin perjudicar la coherencia y la segmentación de la información.

Para llevar a cabo el refinamiento, se buscó medir la información a verbalizar, para saber cuándo es posible convertir una sección. Para esto se propuso como métrica principal a la cantidad de oraciones presentes en la descripción de un tópico.

\subsection{Criterio de reducción de Secciones}
Una sección agrupa uno o más párrafos o sub-secciones, por lo que en una sección puede existir más de un tópico, con la condición de que esos tópicos tengan una relación, ya sea de hermanos o de hijos. Estas relaciones se obtienen de la Estructura de Árbol del Organizador de Información. 

Para decidir si un tópico es planificado como una Sección, se utilizan los siguientes criterios:
\begin{itemize}
    \item Debe poseer cinco o más oraciones.
    \item Debe poseer alguna Subsección con cinco o más oraciones.
    \item En cualquier otro caso será planificado como un Párrafo.
\end{itemize}

Si la cantidad de oraciones requeridas para ser considerado una sección, tiende a cero, la planificación del documento será similar al Documento Inicial; mientras que si la cantidad de oraciones tiende a infinito, la planificación perderá niveles de jerarquía, y únicamente contemplará como secciones a los tópicos del primer nivel. Ninguno de los dos extremos es conveniente: o se pierde coherencia, o se obtiene un texto con demasiados niveles de secciones, que resulta antinatural. Sin embargo, un documento en el que predominan las sub-secciones (aunque tengan poca información), ayuda a los humanos a reconocer y establecer relaciones entre los tópicos, siendo el objetivo principal no desaprovechar la semántica del dominio modelado, y teniendo como intención principal que el lector comprenda el dominio modelado en la ontología.

\section{Implementación del realizador}
El realizador está embebido dentro de la clase Section, en forma de métodos que implementan los criterios vistos para la definición del documento. En la figura~\ref{fig:clase_section} se presenta un pseudocódigo de la clase Section.

\begin{figure}
\begin{minted}[autogobble,linenos]{java}
public class Section {

    private LinkedList<OWLIntClass> topics;
    private Title title;
    private LinkedList<Paragraph> paragraphs;
    private LinkedList<Section> subSections;
    private String language;

    public Section(OWLIntClass topic, String lang) {
        init(lang);
        topics.add(topic);
        title = new Title(topic, lang);
        if (topic.getType().equals("class") ||
        topic.getType().equals("individual")) {
            //crear el Paragraph para la informacion de la seccion
            Paragraph inf = new Paragraph(topic, lang);
            paragraphs.add(inf);
        } 
    }
    
    public String generateText() {
    String textF = "";
    textF = titulo de la Section
    textF += contenido de los Parrafos de la Section
    for (Section s: subSections){
        if (s no cumple los criterios para verbalizar como sección){
            textF += contenido de s en forma de párrafo
        }
    }
    /*La realización de las subsecciones se separa en dos
    recorridos distintos para que todos los párrafos estén
    juntos, y luego aparezcan todas las secciones.*/
    for (Section s: subSections){
        if (s cumple los criterios para verbalizar como sección){
            textF += s.generateText();
        }
    }
    
    return textF;
    }
    
}
\end{minted}
\caption{Definición en Java de la Clase \texttt{Section}.}
\label{fig:clase_section}
\end{figure}


\section{Casos de estudio}
En el capítulo de Organización de Información analizamos cómo quedan organizados los tópicos de las ontologías Pizza y Wine, por lo que continuaremos con estas ontologías de ejemplo, analizando la realización del texto generado. Para identificar el formato del texto, a las secciones se le incluye el número de sección a la izquierda del título de la sección, y cada párrafo comienza con sangría.

\subsection{Generación documento ontología Pizza}
Ya que el texto completo resulta muy extenso, solo pondremos los fragmentos más significativos del Documento Final. En la figura~\ref{fig:doc_final_pizza} se presentan los fragmentos a analizar.

\begin{figure}
\fbox{
\begin{minipage}{14cm}
\setlength{\parindent}{1em}

\noindent 1 Pizza

una pizza es una comida. una pizza tiene base de pizza y tiene cobertura de pizza. Esta tiene como base a alguna base de pizza. Existen las siguientes clases de pizzas: pizza con carne, picante, no vegetariana, con nombre, \dots, con queso y vegetariana. una pizza es disjunta de base de pizza, cobertura de pizza y helado.

Pizza con carne: una pizza con carne es una pizza que tiene como cobertura a alguna cobertura de carne. 
\par \dots Otras pizzas realizadas como párrafos.

\noindent 1.1 Pizza con nombre

una pizza con nombre es una pizza. Existen las siguientes clases de pizzas con nombre: margherita, frutti di mare, \dots, veneziana y napoletana.

Margherita: una margherita es una pizza con nombre. Esta tiene como cobertura a alguna cobertura de mozzarella y tomate. También, margherita tiene exclusivamente las siguientes coberturas: cobertura de mozzarella o de tomate. una margherita es disjunta de american, american hot, \dots, soho y veneziana.

\dots Otras pizzas con nombre realizadas como párrafos.

\noindent 1.2 Ingredientes
	
\noindent 1.2.1 Coberturas
	
\noindent 1.2.1.1 Cobertura de pizza

una cobertura de pizza es una comida. una cobertura de pizza es cobertura de una pizza. Existen las siguientes clases de coberturas de pizza: \dots

\noindent 1.2.2 Bases

\noindent 1.2.2.1 Base de pizza

una base de pizza es una comida. una base de pizza es base de una pizza. Existen las siguientes clases de bases de pizza: base gruesa y delgada y crujiente.
\end{minipage}
}
\caption{Fragmentos del Documento Final generado a partir de la ontología Pizza.}
\label{fig:doc_final_pizza}
\end{figure}
Para visualizar la estructura total del documento, se imprimió el índice de las secciones, el cual se muestra en la Figura~\ref{fig:indice_secciones_pizza}. Se puede apreciar que la estructura del documento comparte algunas similitudes con el Documento Inicial, manteniendo la coherencia global, pero disminuyó la cantidad de secciones, ya que muchas de ellas se convirtieron en párrafos. Aún así, prevalecen títulos de secciones que agregan información semántica aunque no aporten información en forma de texto, tales como Ingredientes, Coberturas y Bases.

\begin{figure}
\begin{multicols}{2}
\begin{figure}[H]
\dirtree{%
.1 Pizza.
.2 Pizza con nombre.
.2 Ingredientes.
.3 Coberturas.
.4 Cobertura de pizza.
.5 Cobertura de verduras.
.6 Cobertura de pimiento.
.6 Cobertura de tomate.
.5 Cobertura de hierbas.
.5 Cobertura de carne.
.5 Cobertura de queso.
.5 Cobertura de pescado.
.3 Bases.
.4 Base de pizza.
.5 Base gruesa.
.5 Base delgada y crujiente.
}
\end{figure}

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.2 Domain concept.
.3 Comida.
.2 Value partition.
.3 Picante.
}
\end{figure}
\end{multicols}
\caption{Índice de secciones del Documento Final generado para la ontología Pizza.}
\label{fig:indice_secciones_pizza}
\end{figure}


\subsection{Generación documento ontología Wine}
Al igual que el caso de estudio anterior, solo incluiremos algunos fragmentos del documento generado, los cuales se pueden ver en la Figura~\ref{fig:doc_final_wine}.

En la Figura~\ref{fig:indice_secciones_wine} se visualiza el índice del documento. El comportamiento es similar al obtenido en la verbalización de la ontología Pizza, comparando la Figura~\ref{fig:indice_secciones_wine} con la Figura~\ref{fig:caso_estudio_wine}, se observa que la estructura resulta mucho más compacta.


\begin{figure}
\fbox{
\begin{minipage}{14cm}
\setlength{\parindent}{1em}
\noindent 1 Wine

a wine is a potable liquid. a wine has wine sugar as sugar, has wine flavor as flavor, has wine body as body, has wine color as color, has wine descriptor and made from grape a wine grape. This located in SOME region. Also, wine has only winery maker. Also, wine has exactly one maker, made at least one wine grape, wine body, wine color, wine flavor and wine sugar. There are the following kinds of wines: italian wine, \dots, late harvest and alsatian wine. 

Full bodied wine: a full bodied wine is a wine that has full body.

\noindent 1.1 Italian wine

a italian wine is a wine that located in italian region. chianti is the only kind of wine. 

Chianti: a chianti is a italian wine. This has only light or medium body. Also, chianti has red color, moderate flavor and dry sugar. located in chianti region. made from grape sangiovese grape. chianti classico is a type of chianti. 

Chianti classico: a chianti classico has mc guinnesso maker and medium body.

\noindent 1.14 Wines descriptor

Wine sugar:	a wine sugar is a wine taste. a wine sugar is a sweet, off dry or dry. there are the wines sugar: dry, off dry and sweet. 


Wine color: a wine color is a wine descriptor. a wine color is a rose, red or white. there are the wines color: white, red and rose. 


Wine flavor: a wine flavor is a wine taste. a wine flavor is a moderate, delicate or strong. there are the wines flavor: moderate, strong and delicate. 

Wine body: a wine body is a wine taste. a wine body is a light, medium or full. there are the wines body: medium, full and light. 

\end{minipage}
}
\caption{Fragmentos del Documento Final generado a partir de la ontología Wine.}
\label{fig:doc_final_wine}
\end{figure}


\begin{figure}
\begin{multicols}{2}
{\small
\begin{figure}[H]
\dirtree{%
.1 Wine.
.2 Italian wine.
.2 Loire.
.2 Table wine.
.2 Pinot noir.
.2 Dessert wine.
.3 Sweet riesling.
.2 Bordeaux.
.3 Medoc.
.2 Riesling.
.2 Red wine.
.3 Red burgundy.
.2 Cabernet sauvignon.
.2 Semillon or sauvignon blanc.
.3 Sauvignon blanc.
.2 White wine.
.3 White burgundy.
.2 Zinfandel.
.2 Chardonnay.
.2 Wines descriptor.
.3 Wine sugar.
.3 Wine color.
.3 Wine flavor.
.3 Wine body.
}
\end{figure}}  

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.1 Region.
.1 Vintage year.
.1 Wine descriptor.
.1 Non consumable thing.
.1 Vintage.
.1 Fruit.
.1 Winery.
.1 Consumable thing.
.2 Meal course.
.3 Foods.
.4 Edible thing.
.5 Seafood.
.5 Pasta.
}
\end{figure}

\end{multicols}
\caption{Resultado del organizador de información con la ontología Wine.}
\label{fig:indice_secciones_wine}
\end{figure}

\section{Conclusiones}

