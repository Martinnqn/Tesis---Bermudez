\chapter{Organización de la información}

\section{Diseño}
La información se organiza en una estructura  jerárquica. La estructura se compone de las entidades presentes en la ontología, de manera que las entidades más relevantes se encuentran en el primer nivel de jerarquía, y a medida que se desciende por los niveles la importancia de las entidades disminuye.

Para alcanzar esta estructura, se crearon una serie de módulos que transforman la entrada hasta alcanzar un árbol con toda la información que posee la ontología. El primer módulo recibe la entrada y crea una representación interna de la ontología, luego esta representación es enviada a otros dos módulos: uno se encarga de extraer las entidades más relevantes; el otro, con la representación interna de la ontología y las entidades más relevantes, se encarga de generar un árbol de entidades. Para finalizar, un último módulo se asegura de agregar aquellas entidades que no han sido utilizadas en ninguna rama del árbol, creando una rama especial del árbol en el que se insertan las entidades que no han sido relacionadas con las demás.

En la figura \ref{fig:modulos_organizador_inf} se muestran los módulos que transforman la entrada en la jerarquía esperada.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=6cm]{img/organizacion_informacion/modulos_organizador_de_informacion.pdf}
    \caption{Módulos que componen el organizador de información}
    \label{fig:modulos_organizador_inf}
\end{figure}

\subsection{Representación interna de la ontología}

El módulo que crea la representación interna de la ontología se encarga de cargar toda la información de la ontología para poder se accedida con mayor facilidad. Como algunos datos son accedidos a través de un razonador o importados de otras ontologías, se optó por cargar toda esta información una única vez para reducir el tiempo de respuesta cuando se requieren esos datos.

\subsection{Clasificación de las entidades más relevantes}
Una vez creada la representación de la ontología, el segundo módulo debe clasificar las entidades y extraer las más relevantes. A continuación se explicará cómo son extraídas estas entidades.

\subsubsection{Criterio de clasificación}
Para este trabajo, asumimos que los grafos subyacentes a las ontologías usadas en la web semántica están caracterizados por ser grafos libres de escala ~\cite{zhang2008scale}. Considerando esta hipótesis, esperamos que la naturaleza de las relaciones brinden información suficiente para discriminar entre el contenido principal y el menos relevante.

El criterio principal para establecer una clasificación sobre las clases de una ontología, y que tal clasificación sirva para seleccionar las clases más relevantes para la verbalización de la ontología, se basa en cuánta información posee una clase respecto al resto de las clases en la ontología. En este trabajo se considera la mayor cantidad de información, a aquellas clases que están presentes en la mayor cantidad de dominios de \emph{ObjectProperties}. Esto permite obtener las clases que tengan mayor cantidad de conexiones con otras clases, y que a su vez sean el núcleo de la relación. Teniendo en cuenta a las clases mejor clasificadas, se puede centrar lo que se dice en el texto alrededor de estas clases.

Visualizando la ontología como un grafo, se puede considerar el grado del nodo como valor para clasificar las clases, pero teniendo en cuenta para el cálculo del grado únicamente los arcos que  
unen a los nodos a través de la relación \emph{rdf:domain}.

Algunas ventajas de este enfoque son:
\begin{itemize}
    \item Sencillez de implementación. Únicamente se debe recorrer el grafo calculando el valor de cada nodo. El recorrido del grafo tiene a lo sumo una complejidad polinomial.
    \item No se requiere agregar información extra al dominio.
    \item No es necesario utilizar sobre la ontología un razonador que requiera una complejidad computacional que sea intratable. La única observación es que hay que inferir el dominio y rango de las \emph{ObjectProperties}. Sin embargo, la inferencia de dominio y rango se realiza teniendo en cuenta la jerarquía de \emph{ObjectProperties}, sin necesidad de inferir clases equivalentes o disjuntas.
\end{itemize}

La eficacia de este enfoque depende fuertemente de que las \emph{ObjectProperties} más importantes tengan el dominio explícito.


\subsubsection{Seleccionando las principales clases}
\label{sec:select_class}
Una vez calculado el valor de cada clase, se pueden seleccionar las clases que superen cierto umbral para remover las menos importantes. En este trabajo, se recorren todas las clases y se seleccionan las que superen el valor promedio entre cantidad de propiedades y cantidad de clases.

Además, se estableció un factor de reducción del umbral, para el caso en el que no exista ninguna clase que supere el umbral seleccionado. Este factor reduce el umbral en 10\%, y se recorren todas las clases nuevamente. Iterativamente, el umbral es reducido hasta encontrar alguna clase que lo supere, o hasta llegar a cero.

Cuando se seleccionan las clases que van a representar los temas principales, puede ocurrir que se elijan clases de una misma rama en la jerarquía de clases. Esto hace que se pierda algo de semántica, pues se incluyen clases en el mismo nivel, siendo que algunas son más específicas y pueden ser alcanzadas desde sus ancestros. Para evitar este problema, se optó por eliminar las subclases que sean seleccionadas en un principio, y que tengan a una clase ancestro dentro de los temas principales.


\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=7cm]{img/organizacion_informacion/secuencia_getMainContent.pdf}
    \caption{Diagrama de secuencia para seleccionar las clases principales}
    \label{fig:diagrama_secuencia_getMainContent}
\end{figure}


\subsection{Agrupando la información de las clases elegidas}
\label{sec:agrupando_info}
Una vez elegidas las clases que serán los temas principales del texto, se procede a crear el árbol completo, con toda la información relacionada a estas clases. Para esto se creó un tercer módulo, que agrupa la información de cada entidad en grupos generales, que abarquen con el mayor nivel de abstracción  posible su información. Para esto, para cada clase, se busca reemplazar las propiedades donde participan como dominio, por propiedades en común de más alto nivel en la jerarquía de \emph{ObjectProperties}. Por ejemplo, en la ontología de las pizzas, para la clase \emph{pizza} existen dos propiedades: \emph{tieneCobertura} y \emph{tieneBase}. Como estas dos propiedades tienen a su vez una \emph{superproperty} en común llamada \emph{tieneIngrediente}, se agrupa toda la información que pueda ser alcanzada por las \emph{subproperties} en un único grupo representado por \emph{tieneIngrediente}. 

Además de la información que puede ser alcanzada desde las \emph{ObjectProperties}, la información que poseen las subclases y los individuos también es de suficiente valor para ser agrupada. En este sentido, las unidades de información representadas por las subclases y los individuos de cada clase elegida como tema relevante, son también incluidas en un grupo. En este caso estamos haciendo uso de las relaciones \emph{owl:subClassOf} y \emph{owl:NamedIndividual}.

Con toda esta información, se crea un primer nivel de grupos que abarcan lo más general posible todos los temas a ser tratados en un texto. Como ejemplo, el primer nivel de la ontología de las pizzas quedaría como en la figura \ref{fig:macro_planning_pizza}.
\begin{figure}[H]
%no borrar el % de dirtree porque es necesario.
\dirtree{%
.1 pizza.
.2 tieneIngrediente.
.2 pizzaConCarne.
.2 pizzaConNombre.
.2 $...$ las restantes subclases de pizza.
}
\caption{Organización del contenido de la ontología \emph{pizza}.}
\label{fig:macro_planning_pizza}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=7cm]{img/organizacion_informacion/secuencia_contentGrouping.pdf}
    \caption{Diagrama de secuencia para agrupar la información de las clases}
    \label{fig:diagrama_secuencia_contentGrouping}
\end{figure}


\subsubsection{Recorriendo la ontología}
Luego de obtener el primer grupo de información, queda pendiente tratar el segundo problema nombrado en \ref{sec:problema_coherencia-texto}: recorrer la ontología obteniendo y agrupando la información relacionada a los temas elegidos. 

El objetivo es establecer una jerarquía de grupos de información, comenzando desde los elementos del primer grupo, que abarcan la información más general, e ir creando nuevos grupos con información más específica. De esta manera, se garantiza que entre los elementos pertenecientes a una rama haya una relación semántica.

Partiendo desde el primer nivel (como los de la figura \ref{fig:macro_planning_pizza}), se aplica el mismo algoritmo usado en \ref{sec:agrupando_info} para obtener el contenido principal, pero esta vez sobre cada elemento del primer nivel. Como ahora es posible que un elemento sea una \emph{ObjectProperty}, para continuar el recorrido de la ontología se buscan sus subproperties, para luego continuar obteniendo información de ellas. Las subproperties elegidas deben contener en su dominio, a la clase que haya sido elegida como tópico para ese grupo de información que se está creando. La búsqueda de subproperties debe ser exhaustiva, pues si no se encuentran subproperties que tengan en su dominio a la clase tópico, debe continuar la búsqueda bajando en la jerarquía de propiedades hasta hallar alguna, ya que es el proceso inverso a la búsqueda de superproperties en común usadas para agrupar la información de manera más general. Si no hay subproperties, entonces la nueva información para agregar en el texto se basa en el rango de la \emph{ObjectProperty} inicial. En este último caso, empleamos la relación \emph{rdf:Range}.

Continuando con el ejemplo de la ontología de la pizza, expandimos la figura \ref{fig:macro_planning_pizza} con el siguiente nivel de información, en la figura \ref{fig:macro_planning_pizza_n2}. 
\begin{figure}[H]
%no borrar el % de dirtree porque es necesario.
\dirtree{%
.1 pizza.
.2 tieneIngrediente.
.3 tieneBase.
.3 tieneCobertura.
.2 pizzaConCarne.
.2 pizzaConNombre.
.3 Margherita.
.3 Napoletana.
.3 $...$ las restantes subclases de pizzaConNombre.
.2 $...$ las restantes subclases de pizza, con sus respectivas subclases.
}
\caption{Organización del contenido de nivel dos de la ontología \emph{pizza}.}
\label{fig:macro_planning_pizza_n2}
\end{figure}

Se puede ver que las subproperties \emph{tieneBase} y \emph{tieneCobertura} tienen en su dominio a \emph{pizza}, la clase más cercana recorriendo sus ancestros. Si existiera por ejemplo, \emph{tieneCondimento} como una tercer subproperty de \emph{tieneIngrediente}, cuyo dominio no tuviera \emph{pizza}, entonces no sería listada dentro del grupo \emph{tieneIngredientes} en la rama de \emph{pizza}. Sin embargo, deben explorarse las subproperties de \emph{tieneCondimento}, por el caso de que tenga alguna subproperty que tuviera como dominio a \emph{pizza}. Por ejemplo, supongamos que \emph{tieneCondimento} tiene como subproperty a \emph{tieneOrégano} con diminio \emph{pizza}, en ese caso se habilita a \emph{tieneCondimento} para ser insertado en el grupo junto a  \emph{tieneCobertura} y \emph{tieneBase}.  

De esta manera, el mismo algoritmo se aplica recursivamente para cada elemento de cada nivel. El algoritmo se detiene cuando no encuentra más subclases ni propiedades para cada clase del último nivel.

\subsection{Agregando información marginada}
Con el recorrido de la ontología para formar los grupos de información, existe la posibilidad de que hayan clases que no sean parte de un grupo. Es el caso, por ejemplo, de la clase \emph{Comida}, y sus subclases \emph{Helado} y \emph{Condimento}, en la ontología \emph{pizza}. Para no dejar información del dominio excluida en el árbol, se ejecuta un cuarto módulo, que crea un nuevo grupo menos importante, y se agregan todas las clases que habían quedado marginadas. El proceso de creación de subgrupos para este nuevo grupo es idéntico al explicado en las sección anterior.

Continuando con el ejemplo de la pizza, el resultado de agregar la  información marginada se muestra en la figura \ref{fig:macro_planning_pizza_marg}

\begin{figure}[H]
%no borrar el % de dirtree porque es necesario.
\dirtree{%
.1 pizza.
.2 ....
.1 comida.
.2 condimento.
.2 helado.
}
\caption{Grupos de la ontología \emph{pizza} con información marginada.}
\label{fig:macro_planning_pizza_marg}
\end{figure}

\subsection{Diagrama de clases}
En la figura \ref{fig:diagrama_clases_organizador} se muestra el diagrama de clases correspondiente al organizador de información. El primer módulo tiene asociado las clases \emph{Ontology} y \emph{OWLIntClass}. El segundo módulo está representado por la clases \emph{ContentClasification}; y el tercer y cuarto módulo están asociados a la clase \emph{ContentGrouping}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{img/organizacion_informacion/clases_organizador_informacion.pdf}
    \caption{Diagrama de clases del organizador de información}
    \label{fig:diagrama_clases_organizador}
\end{figure}

\section{Implementación}
\subsection{blabla}

\section{Casos de estudio}
En esta sección se presentan tres casos de estudio que muestran el comportamiento de la aplicación ante tres entradas diferentes, abarcando distintos aspectos de la solución propuesta.

Al momento de realizar este trabajo no se reconoce ninguna aplicación que aborde el problema de organización de la información en una ontología, por lo que se expondrán tres casos de estudio sin la posibilidad de compararlos con otros resultados.

\subsection{Organización de Ontología Pizza}
La ontología pizza cuenta con 100 clases y 8 propiedades.

Según la descripción de la ontología, este dominio representa las pizzas y sus coberturas, por lo que esperamos que las entidades que representen a las pizzas, a las coberturas y la información complementaria tiendan a agruparse en los niveles más altos de la jerarquía, mientras que en los niveles más bajas esperamos encontrar las clases más específicas y que tienen menor impacto sobre el entendimiento del dominio.

En la figura \ref{fig:caso_estudio_pizza} se puede ver el resultado de aplicar el algoritmo teniendo como entrada la ontología pizza. 

Los nombres de las entidades fueron traducidos al español, para poder generar las sentencias en lenguaje español en el siguiente capítulo, pero el idioma no afecta los resultados del algoritmo propuesto.

\begin{figure}
\begin{multicols}{2}
\begin{figure}[H]
\dirtree{%
.1 Pizza.
.2 Pizza con nombre.
.3 Margherita.
.3 Frutti di mare.
.3 Giardiniera.
.3 ....
.3 Napoletana.
.2 Pizza con carne.
.2 Pizza picante.
.2 ....
.2 Pizza vegetariana.
.2 Ingredientes.
.3 Coberturas.
.4 Cobertura de pizza.
.5 Cobertura de verduras.
.6 Cobertura de pimiento.
.6 ....
.6 Cobertura de langostinos.
.3 Bases.
.4 Base de pizza.
.5 Base gruesa.
.5 Base delgada y crujiente.
.5 Condimentoes.
.6 Sales.
.7 Sal.
}
\end{figure}

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.2 Domain concept.
.3 Comida.
.4 Helado.
.4 Ingrediente.
.3 Pais.
.4 America.
.4 England.
.4 Italy.
.4 France.
.4 Germany.
.2 Value partition.
.3 Picante.
.4 Poco picante.
.4 Algo picante.
.4 Muy picante.
}
\end{figure}

\end{multicols}
\caption{Resultado del organizador de información con la ontología Pizza.}
\label{fig:caso_estudio_pizza}
\end{figure}

Como se puede observar, en la primer columna se encuentran los tópicos principales reconocidos por el algoritmo, y en la segunda columna se encuentran los tópicos agregados con el módulo para agregar información marginada.

En la jerarquía de los tópicos principales, se puede ver como toda la información se agrupa como hijas de la entidad pizza, describiendo los tipos de pizzas y sus ingredientes. Inmediato a los ingredientes lista las coberturas, y reconoce a las bases de pizza a la misma altura que las coberturas, asignándoles la misma importancia.

En la jerarquía de \emph{otras secciones}, se aprecian las demás entidades que aportan información secundaria a la descripción del dominio, que no está directamente relacionada con el dominio de las pizzas, como son los países, los tipos de picante y otras comidas.

El resultado obtenido es satisfactorio, cumple con el comportamiento esperado, y se asimila a la propia descripción del dominio. 

De las 8 propiedades, 5 fueron suficiente para clasificar las 100 clases de manera satisfactoria (de las 8, 3 eran inversas a otras 3 por lo que no agregaban información nueva).  

\subsection{Organización de Ontología Wine}
La ontología wine cuenta con 138 clases y 16 propiedades.

Esta ontología tiene como objetivo describir un dominio de vinos y comidas \footnote{\url{https://protege.stanford.edu/publications/ontology_development/ontology101-noy-mcguinness.html}}, por lo que esperamos que las entidades que se consideren más relevantes sean aquellas afines a los vinos y comidas.

\begin{figure}
\begin{multicols}{2}
\begin{figure}[H]
\dirtree{%
.1 Wine.
.2 Italian wine.
.2 Full bodied wine.
.2 Petite syrah.
.2 Bordeaux.
.3 White bordeaux.
.3 St emilion.
.4 Chateau cheval blanc st emilion.
.3 Medoc.
.4 Margaux.
.5 Chateau margaux.
.2 $...$ (\emph{otros vinos}). 
.2 Wines descriptor.
.3 Sugar.
.4 ....
.3 Colors.
.4 ....
.3 Flavors.
.4 ....
.3 Bodies.
.4 ....
.2 From grapes.
.3 ....
}
\end{figure}

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.2 Region.
.3 Central texas region.
.3 Texas region.
.3 $...$ (\emph{otras regiones}).
.2 Vintage year.
.3 Year1998.
.2 Wine descriptor.
.3 Wine taste.
.2 Non consumable thing.
.2 Vintage.
.3 Vintage years.
.2 Fruit.
.2 Winery.
.3 Chateau de meursault.
.3 St genevieve.
.3 Congress springs.
.3 $...$ (\emph{otras Winery}).
.2 Consumable thing.
.3 Meal.
.4 Courses.
.5 Meal course.
.6 Non spicy red meat course.
.6 Shellfish course.
.6 $...$ (\emph{otros meal course}).
.6 Foods.
.7 Edible thing.
.8 $...$ (\emph{otras subclases de Edible thing}).
.6 Drinks.
.7 Potable liquid.
.8 Wine.
.9 Juice.
.3 From fruits.
}
\end{figure}

\end{multicols}
\caption{Resultado del organizador de información con la ontología Wine.}
\label{fig:caso_estudio_wine}
\end{figure}


\subsection{Organización de Ontología SNOMED-CT}

\section{Conclusiones}