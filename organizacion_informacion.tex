\chapter{Organización de la información}

\section{Introducción}
Para abordar los problemas de coherencia propuestos en la Sección~\ref{sec:problema_coherencia-texto}, es necesario crear una estructura jerárquica para guiar el desarrollo del texto. Esta estructura está compuesta por las entidades presentes en la ontología, de manera que las entidades que consideramos más relevantes se encuentren en el primer nivel de jerarquía, y a medida que se descienda por los niveles la importancia de las entidades disminuya.

\section{Diseño}
Para alcanzar esta estructura, se crearon cuatro módulos que transforman la ontología de entrada en un árbol con toda la información contenida en la misma.
A continuación se describe cada módulo:
\begin{itemize}
    \item Traductor: recibe la entrada y la traduce a una representación interna de la ontología.
    \item Clasificador de Entidades: clasifica y extrae las entidades más relevantes, utilizando como criterio las medidas de centralidad.
    \item Generador de Nuevo Grupo de Entidades: recibe una Entidad y recorre sus relaciones para crear un nuevo grupo de entidades relacionados semánticamente.
    \item Generador del Árbol de Entidades: se encarga de crear los niveles de la estructura jerárquica, interactuando con el Generador de Nuevo Grupo de Entidades.
    
\end{itemize}
%Para finalizar, un último módulo agrega en una nueva rama del árbol a aquellas entidades que no han sido utilizadas en ninguna otra rama.

En la Figura~\ref{fig:modulos_organizador_inf} se muestra la transformación de la ontología OWL a través de los módulos. Los pasos 4 y 5 son iterativos, el proceso finaliza cuando no queden más Entidades que explorar, lo cual es definido por el Generador del Árbol de Entidades.

\begin{figure}[H]
    \centering
    \includegraphics%[width=12cm, height=6cm]
    [scale=1]{img/organizacion_informacion/modulos_organizador_de_informacion.pdf}
    \caption{Módulos que componen el organizador de información}
    \label{fig:modulos_organizador_inf}
\end{figure}


\subsection{Traductor de la entrada}
El módulo que crea la representación interna de la ontología se encarga de cargar toda la información de la ontología para poder ser accedida con mayor facilidad. Como algunos datos son accedidos a través de un razonador o importados de otras ontologías, se optó por cargar toda esta información una única vez para reducir el tiempo de espera cuando se requieren estos datos.

La estructura captura los componentes de la ontología, y los relaciona para poder ser accedidos y recorridos como un grafo. 

\subsection{Clasificación de las entidades más relevantes}
Una vez creada la representación de la ontología, el segundo módulo debe clasificar las entidades y extraer las más relevantes. A continuación se explicará cómo son extraídas estas entidades.

\subsubsection{Criterio de clasificación}
El criterio principal para establecer una clasificación sobre las clases de una ontología, y que tal clasificación sirva para seleccionar las clases más relevantes, se basa en cuánta información posee una clase respecto al resto de las clases en la ontología. Consideramos que una clase tiene más información que otra si está presente en más cantidad de dominios de \emph{ObjectProperties}. Esto permite reconocer las clases que tengan mayor cantidad de conexiones con otras clases, y que a su vez sean el núcleo de la relación. 

Para obtener la cantidad de información de cada clase, utilizaremos el grafo subyacente a la ontología y calcularemos el \emph{outdegree} de cada nodo que represente una clase. Para el cálculo se tendrá en cuenta únicamente la relación \emph{rdf:domain}.

Teniendo en cuenta a las clases mejor clasificadas, se puede centrar lo que se dice en el texto alrededor de estas clases.

Algunas ventajas de este enfoque son:
\begin{itemize}
    \item Sencillez de implementación. Únicamente se debe recorrer el grafo calculando el valor de cada nodo. El recorrido del grafo tiene a lo sumo una complejidad polinomial.
    \item No se requiere agregar información extra al dominio.
    \item No es necesario utilizar sobre la ontología un razonador que requiera una complejidad computacional que sea intratable. La única observación es que hay que inferir el dominio y rango de las \emph{ObjectProperties}. Sin embargo, la inferencia de dominio y rango se realiza teniendo en cuenta la jerarquía de \emph{ObjectProperties}, sin necesidad de inferir clases equivalentes o disjuntas.
\end{itemize}

La eficacia de este enfoque depende fuertemente de que las \emph{ObjectProperties} más importantes tengan el dominio explícito.


\subsubsection{Seleccionando las principales clases}
\label{sec:select_class}
Una vez calculado el valor de cada clase, se pueden seleccionar las clases que superen cierto umbral para agregarlas al primer nivel de la estructura jerárquica que guiará el desarrollo del texto. En este trabajo, se recorren todas las clases y se seleccionan las que superen el valor promedio entre cantidad de propiedades y cantidad de clases.

Si ninguna supera el valor promedio, se selecciona la o las clases con el valor más alto.

Cuando se seleccionan las clases que van a representar los temas principales, puede ocurrir que se elijan clases de una misma rama en la jerarquía de clases. Esto hace que se pierda algo de semántica, pues se incluyen clases en el mismo nivel, siendo que algunas son más específicas y pueden ser alcanzadas desde sus ancestros. Para evitar este problema, se optó por eliminar las subclases que sean seleccionadas en un principio, y que tengan a una clase ancestro dentro de los temas principales. Por ejemplo, continuando con la ontología de las pizzas, si las principales clases seleccionadas son \emph{comida} y \emph{pizza}, la clase \emph{pizza} sería eliminada del conjunto, pues es subclase de \emph{comida}. En las secciones siguientes se verá que la subclase \emph{pizza} aparecerá en el siguiente nivel correspondiente a la rama \emph{comida}.

\subsection{Agrupando la información de las clases elegidas}
\label{sec:agrupando_info}
Una vez elegidas las clases que estarán en el primer nivel de la jerarquía, se procede a crear los niveles siguientes, con toda la información relacionada a estas clases. Para esto se creó un tercer módulo, que agrupa la información de cada entidad en grupos generales, que abarquen con el mayor nivel de abstracción posible su información. Para cada clase, se busca reemplazar las propiedades donde participan como dominio, por propiedades en común de más alto nivel en la jerarquía de \emph{ObjectProperties}. Por ejemplo, en la ontología de las pizzas, para la clase \emph{pizza} existen dos propiedades: \emph{tieneCobertura} y \emph{tieneBase}. Como estas dos propiedades tienen a su vez una \emph{superproperty} en común llamada \emph{tieneIngrediente}, se agrupa toda la información que pueda ser alcanzada por las \emph{subproperties} en un único grupo representado por \emph{tieneIngrediente}. 

Además de la información que puede ser alcanzada desde las \emph{ObjectProperties}, la información que poseen las Subclases y los Individuos también es agrupada. En este caso estamos haciendo uso de las relaciones \emph{owl:subClassOf} y \emph{owl:NamedIndividual}.

En la Figura~\ref{fig:diagrama_secuencia_contentGrouping} se muestra un pseudocódigo del algoritmo usado para agrupar la información de las clases.

Con toda esta información, se crea un primer nivel de grupos que abarcan lo más general posible todos los temas a ser tratados en un texto. Como ejemplo, el primer nivel de la ontología de las pizzas quedaría como en la figura~\ref{fig:macro_planning_pizza}.

\begin{figure}[H]
\centering
\begin{minipage}[c]{0.7\textwidth}
%no borrar el % de dirtree porque es necesario.
{\footnotesize 
\dirtree{%
.1 pizza.
.2 tieneIngrediente.
.2 pizzaConCarne.
.2 pizzaConNombre.
.2 $\ldots$ las restantes subclases de pizza.
}}
\caption{Organización del contenido de la ontología \emph{pizza}.}
\label{fig:macro_planning_pizza}
\end{minipage}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics%[width=8cm, height=7cm]
    [scale=0.8]{img/organizacion_informacion/secuencia_contentGrouping}
    \caption{Diagrama de secuencia para agrupar la información de las clases}
    \label{fig:diagrama_secuencia_contentGrouping}
\end{figure}


\subsubsection{Recorriendo la ontología}
Luego de obtener el primer grupo de información, queda pendiente tratar el segundo problema nombrado en la Sección~\ref{sec:problema_coherencia-texto}: recorrer la ontología obteniendo y agrupando la información relacionada a los temas elegidos. 

El objetivo es establecer una jerarquía de grupos de información, comenzando desde los elementos del primer grupo, que abarcan la información más general, e ir creando nuevos grupos con información más específicos. De esta manera, se garantiza que entre los elementos pertenecientes a una rama haya una relación semántica.

Partiendo desde el primer nivel (como los de la Figura~\ref{fig:macro_planning_pizza}), se aplica el mismo algoritmo usado en la Sección~\ref{sec:agrupando_info} para obtener el contenido principal, pero esta vez sobre cada elemento de dicho nivel. Como ahora es posible que un elemento sea una \emph{ObjectProperty}, para continuar el recorrido de la ontología se buscan sus {\tt subproperties}, para luego continuar obteniendo información de ellas. Las subproperties elegidas deben contener en su dominio, a la clase que haya sido elegida como tópico para ese grupo de información que se está creando. La búsqueda de subproperties debe ser exhaustiva, pues si no se encuentran subproperties que tengan en su dominio a la clase tópico, debe continuar la búsqueda bajando en la jerarquía de propiedades hasta hallar alguna, ya que es el proceso inverso a la búsqueda de superproperties en común usadas para agrupar la información de manera más general. Si no hay subproperties, entonces la nueva información para agregar en el texto se basa en el rango de la \emph{ObjectProperty} inicial. En este último caso, empleamos la relación \emph{rdf:Range}.

Continuando con el ejemplo de la ontología de la pizza, expandimos la figura~\ref{fig:macro_planning_pizza} con el siguiente nivel de información, en la figura~\ref{fig:macro_planning_pizza_n2}. 
\begin{figure}[H]
\centering
\begin{minipage}[c]{0.7\textwidth}
%no borrar el % de dirtree porque es necesario.
{\footnotesize 
\dirtree{%
.1 pizza.
.2 tieneIngrediente.
.3 tieneBase.
.3 tieneCobertura.
.2 pizzaConCarne.
.2 pizzaConNombre.
.3 Margherita.
.3 Napoletana.
.3 $...$ las restantes subclases de pizzaConNombre.
.2 $...$ las restantes subclases de pizza, con sus respectivas subclases.
}}
\caption{Organización del contenido de nivel dos de la ontología \emph{pizza}.}
\label{fig:macro_planning_pizza_n2}
\end{minipage}
\end{figure}

Se puede ver que las subproperties \emph{tieneBase} y \emph{tieneCobertura} tienen en su dominio a \emph{pizza}, la clase más cercana recorriendo sus ancestros. Si existiera por ejemplo, \emph{tieneCondimento} como una tercer subproperty de \emph{tieneIngrediente}, cuyo dominio no tuviera \emph{pizza}, entonces no sería listada dentro del grupo \emph{tieneIngredientes} en la rama de \emph{pizza}. Sin embargo, deben explorarse las subproperties de \emph{tieneCondimento}, por el caso de que tenga alguna subproperty que tuviera como dominio a \emph{pizza}. Por ejemplo, supongamos que \emph{tieneCondimento} tiene como subproperty a \emph{tieneOrégano} con diminio \emph{pizza}, en ese caso se habilita a \emph{tieneCondimento} para ser insertado en el grupo junto a  \emph{tieneCobertura} y \emph{tieneBase}.  

De esta manera, el mismo algoritmo se aplica recursivamente para cada elemento de cada nivel. El algoritmo se detiene cuando no encuentra más subclases ni propiedades para cada clase del último nivel.

\subsection{Agregando información marginada}
Con el recorrido de la ontología para formar los grupos de información, existe la posibilidad de que hayan clases que no sean parte de un grupo. Es el caso, por ejemplo, de la clase \emph{Comida}, y sus subclases \emph{Helado} y \emph{Condimento}, en la ontología \emph{pizza}. Para no dejar información del dominio excluida en el árbol, se ejecuta un cuarto módulo, que crea un nuevo grupo menos importante, y se agregan todas las clases que habían quedado marginadas. El proceso de creación de subgrupos para este nuevo grupo es idéntico al explicado en las sección anterior.

Continuando con el ejemplo de la pizza, el resultado de agregar la  información marginada se muestra en la figura~\ref{fig:macro_planning_pizza_marg}

\begin{figure}[H]
\centering
\begin{minipage}[c]{0.7\textwidth}
{\footnotesize 
\dirtree{%
.1 pizza.
.2 ....
.1 comida.
.2 condimento.
.2 helado.
}
}
\caption{Grupos de la ontología \emph{pizza} con información marginada.}
\label{fig:macro_planning_pizza_marg}
\end{minipage}
\end{figure}

\subsection{Diagrama de clases}
En la Figura~\ref{fig:diagrama_clases_organizador} se muestra el diagrama de clases correspondiente al Organizador de Información. El módulo \emph{Traductor} está representado a través de la clase \emph{OntologyManager}; el módulo Clasificador de Entidades está representado por la clase \emph{ContentClasification}; el módulo que genera el Árbol de Entidades está implementado por la clase \emph{GeneratorTreeManager}, y el módulo que crea nuevos grupos de entidades está implementado en la clase \emph{ContentGrouping}. 

\begin{figure}
    \centering
    \includegraphics{img/organizacion_informacion/clases_organizador_informacion.pdf}
    \caption{Diagrama de clases del organizador de información}
    \label{fig:diagrama_clases_organizador}
\end{figure}

\section{Implementación}
\subsection{blabla}

\section{Casos de estudio}
En esta sección se presentan tres casos de estudio que muestran el comportamiento de la aplicación ante tres entradas diferentes, abarcando distintos aspectos de la solución propuesta.

Al momento de realizar este trabajo no se reconoce ninguna aplicación que aborde el problema de organización de la información en una ontología, por lo que se expondrán tres casos de estudio sin la posibilidad de compararlos con otros resultados.

\subsection{Organización de Ontología Pizza}
Según la descripción de la ontología, este dominio representa las pizzas y sus coberturas, por lo que esperamos que las entidades que representen a las pizzas, a las coberturas y la información complementaria tiendan a agruparse en los niveles más altos de la jerarquía, mientras que en los niveles más bajas esperamos encontrar las clases más específicas y que tienen menor impacto sobre el entendimiento del dominio.

En la Figura~\ref{fig:caso_estudio_pizza} se puede ver el resultado de aplicar el algoritmo teniendo como entrada la ontología pizza. 

Los nombres de las entidades fueron traducidos al español, para poder generar las sentencias en lenguaje español en el siguiente capítulo, pero el idioma no afecta los resultados del algoritmo propuesto.

\begin{figure}
\begin{multicols}{2}
\begin{figure}[H]
\dirtree{%
.1 Pizza.
.2 Pizza con nombre.
.3 Margherita.
.3 Frutti di mare.
.3 Giardiniera.
.3 ....
.3 Napoletana.
.2 Pizza con carne.
.2 Pizza picante.
.2 ....
.2 Pizza vegetariana.
.2 Ingredientes.
.3 Coberturas.
.4 Cobertura de pizza.
.5 Cobertura de verduras.
.6 Cobertura de pimiento.
.6 ....
.6 Cobertura de langostinos.
.3 Bases.
.4 Base de pizza.
.5 Base gruesa.
.5 Base delgada y crujiente.
.5 Condimentoes.
.6 Sales.
.7 Sal.
}
\end{figure}

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.2 Domain concept.
.3 Comida.
.4 Helado.
.4 Ingrediente.
.3 Pais.
.4 America.
.4 England.
.4 Italy.
.4 France.
.4 Germany.
.2 Value partition.
.3 Picante.
.4 Poco picante.
.4 Algo picante.
.4 Muy picante.
}
\end{figure}

\end{multicols}
\caption{Resultado del organizador de información con la ontología Pizza.}
\label{fig:caso_estudio_pizza}
\end{figure}

La ontología pizza cuenta con 100 clases y 8 propiedades. De las 8 propiedades, 5 fueron usadas  para clasificar las 100 clases (de las 8, 3 eran inversas a otras 3 por lo que no agregaban información nueva). El promedio de información obtenido fue 1.25, siendo la clase Pizza la única en superar este valor, lo que concuerda con el resultado esperado.

Como se puede observar en la Figura~\ref{fig:caso_estudio_pizza}, en la primer columna se encuentran los tópicos principales reconocidos por el algoritmo, y en la segunda columna se encuentran los tópicos agregados con el módulo para agregar información marginada.

En la jerarquía de los tópicos principales, se puede ver como toda la información se agrupa como hijas de la entidad Pizza, describiendo los tipos de pizzas y sus ingredientes. Inmediato a los ingredientes lista las coberturas, y reconoce a las bases de pizza a la misma altura que las coberturas, asignándoles la misma importancia.

En la jerarquía de \emph{otras secciones}, se aprecian las demás entidades que aportan información secundaria a la descripción del dominio, que no está directamente relacionada con el dominio de las pizzas, como son los países, los tipos de picante y otras comidas.

Respecto al resultado esperado, la organización de la información es satisfactoria, ya que se asimila a la propia descripción del dominio. 

\subsection{Organización de Ontología Wine}
Esta ontología tiene como objetivo describir un dominio de vinos y comidas\footnote{\url{https://protege.stanford.edu/publications/ontology_development/ontology101-noy-mcguinness.html}}, por lo que esperamos que las entidades que se consideren más relevantes sean aquellas afines a los vinos y comidas.

En la Figura~\ref{fig:caso_estudio_wine} se puede ver el resultado de aplicar el algoritmo teniendo como entrada la ontología Wine.

\begin{figure}
\begin{multicols}{2}
{\small
\begin{figure}[H]
\dirtree{%
.1 Wine.
.2 Italian wine.
.3 Chianti.
.4 Chianti classico.
.2 $...$ \emph{(otras subclases de Wine)}.
.2 Wines descriptor.
.3 Sugar.
.4 Wine sugar.
.5 Dry.
.5 Off dry.
.5 Sweet.
.3 Colors.
.4 Wine color.
.5 White.
.5 Rose.
.5 Red.
.3 Flavors.
.4 Wine flavor.
.5 Moderate.
.5 Strong.
.5 Delicate.
.3 Bodies.
.4 Wine body.
.5 Medium.
.5 Full.
.5 Light.
.2 From grapes.
.3 Wine grape.
.4 Chenin blanc grape.
.4 $...$ \emph{(otras subclases de Wine grape)}.
}
\end{figure}}  

\begin{figure}[H]
\dirtree{%
.1 Otras secciones.
.1 Region.
.2 Central texas region.
.2 $...$ \emph{(otras subclases de Region)}.
.1 Vintage year.
.2 Year1998.
.1 Wine descriptor.
.2 Wine taste.
.1 Non consumable thing.
.1 Vintage.
.2 Vintage years.
.1 Fruit.
.1 Winery.
.2 Chateau de meursault.
.2 $...$ \emph{(otras subclases de Winery)}.
.1 Consumable thing.
.2 Meal.
.3 Courses.
.4 Meal course.
.5 Cheese nuts dessert course.
.5 $...$ \emph{(otras subclases de Meal course)}.
.5 Foods.
.6 Edible thing.
.7 Fowl.
.8 $...$.
.7 Dessert.
.8 $...$.
.7 Meat.
.8 $...$.
.7 Seafood.
.8 $...$.
.7 Sweet fruit.
.8 Grape.
.8 $...$.
.7 Pasta.
.8 $...$.
.7 Non sweet fruit.
.5 Drinks.
.6 Potable liquid.
.7 Juice.
.7 Wine.
.8 Wines descriptor.
.8 From fruits.
}
\end{figure}

\end{multicols}
\caption{Resultado del organizador de información con la ontología Wine.}
\label{fig:caso_estudio_wine}
\end{figure}


La ontología Wine cuenta con 138 clases y 16 propiedades. De las 16 propiedades, 12 fueron usadas para verificar qué clases superan el umbral promedio para ser seleccionadas como las principales. El promedio fue de 2.5 y la única clase que lo superó fue Wine, lo que cumple parcialmente el resultado esperado, ya que parte del objetivo de la ontología es describir el dominio de los \emph{Wines}. Respecto a la sección que describe las comidas, quedó desplazada a \emph{otras secciones}, siendo un resultado no esperado según el objetivo de la ontología. Sin embargo, analizando manualmente la ontología, se puede apreciar que el porcentaje de  información que describe a las comidas es significativamente menor en relación a la información referida a los vinos, factor por el cual resulta aceptable que no aparezcan como sección principal.

%\subsection{Organización de Ontología SNOMED-CT}

\section{Conclusiones}